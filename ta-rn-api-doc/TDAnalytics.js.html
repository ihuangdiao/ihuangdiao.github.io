<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>TDAnalytics.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="TDAnalytics.html">TDAnalytics</a><ul class='methods'><li data-type='method'><a href="TDAnalytics.html#.calibrateTime">calibrateTime</a></li><li data-type='method'><a href="TDAnalytics.html#.calibrateTimeWithNtp">calibrateTimeWithNtp</a></li><li data-type='method'><a href="TDAnalytics.html#.init">init</a></li><li data-type='method'><a href="TDAnalytics.html#.init">init</a></li><li data-type='method'><a href="TDAnalytics.html#.track">track</a></li><li data-type='method'><a href="TDAnalytics.html#.trackFirst">trackFirst</a></li><li data-type='method'><a href="TDAnalytics.html#.trackUpdate">trackUpdate</a></li><li data-type='method'><a href="TDAnalytics.html#.trackOverwrite">trackOverwrite</a></li><li data-type='method'><a href="TDAnalytics.html#.timeEvent">timeEvent</a></li><li data-type='method'><a href="TDAnalytics.html#.enableAutoTrack">enableAutoTrack</a></li><li data-type='method'><a href="TDAnalytics.html#.enableAutoTrack">enableAutoTrack</a></li><li data-type='method'><a href="TDAnalytics.html#.userSet">userSet</a></li><li data-type='method'><a href="TDAnalytics.html#.userSetOnce">userSetOnce</a></li><li data-type='method'><a href="TDAnalytics.html#.userUnset">userUnset</a></li><li data-type='method'><a href="TDAnalytics.html#.userAdd">userAdd</a></li><li data-type='method'><a href="TDAnalytics.html#.userAppend">userAppend</a></li><li data-type='method'><a href="TDAnalytics.html#.userUniqAppend">userUniqAppend</a></li><li data-type='method'><a href="TDAnalytics.html#.userDelete">userDelete</a></li><li data-type='method'><a href="TDAnalytics.html#.setSuperProperties">setSuperProperties</a></li><li data-type='method'><a href="TDAnalytics.html#.unsetSuperProperty">unsetSuperProperty</a></li><li data-type='method'><a href="TDAnalytics.html#.clearSuperProperties">clearSuperProperties</a></li><li data-type='method'><a href="TDAnalytics.html#.getSuperProperties">getSuperProperties</a></li><li data-type='method'><a href="TDAnalytics.html#.setDynamicSuperProperties">setDynamicSuperProperties</a></li><li data-type='method'><a href="TDAnalytics.html#.getPresetProperties">getPresetProperties</a></li><li data-type='method'><a href="TDAnalytics.html#.login">login</a></li><li data-type='method'><a href="TDAnalytics.html#.logout">logout</a></li><li data-type='method'><a href="TDAnalytics.html#.setDistinctId">setDistinctId</a></li><li data-type='method'><a href="TDAnalytics.html#.getDistinctId">getDistinctId</a></li><li data-type='method'><a href="TDAnalytics.html#.getDeviceId">getDeviceId</a></li><li data-type='method'><a href="TDAnalytics.html#.flush">flush</a></li><li data-type='method'><a href="TDAnalytics.html#.setTrackStatus">setTrackStatus</a></li><li data-type='method'><a href="TDAnalytics.html#.enableThirdPartySharing">enableThirdPartySharing</a></li></ul></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">TDAnalytics.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
import thinkingdata, { AutoTrackEventType, TAThirdPartyShareType, TATrackStatus } from "./ThinkingAnalyticsAPI";
const TDAutoTrackEventType = {
    APP_START:  1,
    APP_END: 1 &lt;&lt; 1,
    APP_CRASH: 1 &lt;&lt; 2,
    APP_INSTALL: 1 &lt;&lt; 3
}
const TDTrackStatus = {
    PAUSE: 'pause',
    STOP: 'stop',
    SAVE_ONLY: 'saveOnly',
    NORMAL: 'normal'
}
const TDThirdPartyType = {
    APPS_FLYER: 1,
    IRON_SOURCE: 1 &lt;&lt; 1,
    ADJUST: 1 &lt;&lt; 2,
    BRANCH: 1 &lt;&lt; 3,
    TOP_ON: 1 &lt;&lt; 4,
    TRACKING: 1 &lt;&lt; 5,
    TRAD_PLUS: 1 &lt;&lt; 6
}
/**
 * @class
 */
class TDAnalytics{
    static instances = {};
    /**
     * time calibration with timestamp
     * @param {long} time timestamp
     */
    static calibrateTime(time){
        thinkingdata.calibrateTime(time);
    }

    /**
     * time calibration with ntp
     * @param {String} ntp_server  ntp server url
     */
    static calibrateTimeWithNtp(ntp_server){
        thinkingdata.calibrateTimeWithNtp(ntp_server);
    }

    /**
     * Initialize the SDK. The track function is not available until this interface is invoked.
     * @param {String} appId app id,required
     * @param {String} serverUrl server url,required
     */
    static init(appId,serverUrl){
        var config = {
            appid: appId,
            serverUrl: serverUrl
        }
        if(Object.keys(this.instances).length == 0){
            thinkingdata.init(config);
            this.instances[appId]= thinkingdata;
        }else{
            var instance = thinkingdata.initInstance(config);
            this.instances[appId]= instance;
        }
    }
    
    /**
     * Initialize the SDK with config. The track function is not available until this interface is invoked.
     * @param {Object} config init config
     * 
     * @property {String} appId config.appid,required
     * @property {String} serverUrl config.serverUrl,required
     * @property {boolean} enableEncrypt config.enableEncrypt whether to enable encryption,optional
     * @property {Object} secretKey config.secretKey encrypt configuration information,optional
     * @property {boolean} enableLog config.enableLog whether to enable local logging,optional
     * @property {String} timeZone config.timeZone default time zone,optional
     */
    static init(config = {}){
        if(config['appId']){
            config['appid']= config['appId'];
        }
        if(Object.keys(this.instances).length == 0){
            thinkingdata.init(config);
            this.instances[config.appid]= thinkingdata;
        }else{
            var instance = thinkingdata.initInstance(config);
            this.instances[config.appid]= instance;
        }
    }

    /**
     * Upload a single event, containing only preset properties and set public properties.
     * @param {Object} options event infomations
     * 
     * @property {String} eventName options.eventName event name, required
     * @property {Object} properties  options.properties event properties, optional
     * @property {long} time  options.time event timeStamp, optional
     * @property {String} timeZone  options.timeZone event time zone, optional
     * @property {String} appId app id,optional
     */
    static track(options = {}){
        if(options['appId']){
            this.instances[options['appId']].track(options['eventName'],options['properties'],options['time'],options['timeZone']);
        }else{
            thinkingdata.track(options['eventName'],options['properties'],options['time'],options['timeZone']);
        }
    }

    /**
     * Sending First Event
     * @param {Object} options event infomations
     * 
     * @property {String} eventName options.eventName event name, required
     * @property {Object} properties  options.properties event properties, optional
     * @property {String} eventId  options.eventId event ID, to mark the event, optional
     * @property {long} time  options.time event timeStamp, optional
     * @property {String} timeZone  options.timeZone event time zone, optional
     * @property {String} appId app id,optional
     */
    static trackFirst(options = {}){
        if(options['appId']){
            this.instances[options['appId']].trackFirstEvent(options['eventName'],options['properties'],options['eventId'],options['time'],options['timeZone']);
        }else{
            thinkingdata.trackFirstEvent(options['eventName'],options['properties'],options['eventId'],options['time'],options['timeZone']);
        }
    }

    /**
     * Sending Updatable Event
     * @param {Object} options event infomations
     * 
     * @property {String} eventName options.eventName event name, required
     * @property {Object} properties  options.properties event properties, optional
     * @property {String} eventId  options.eventId event ID, to mark the event, optional
     * @property {long} time  options.time event timeStamp, optional
     * @property {String} timeZone  options.timeZone event time zone, optional
     * @property {String} appId app id,optional
     */
    static trackUpdate(options = {}){
        if(options['appId']){
            this.instances[options['appId']].trackUpdate(options['eventName'],options['properties'],options['eventId'],options['time'],options['timeZone']);
        }else{
            thinkingdata.trackUpdate(options['eventName'],options['properties'],options['eventId'],options['time'],options['timeZone']);
        }
    }

    /**
     * Sending Overwritable Event
     * @param {Object} options event infomations
     * 
     * @property {String} eventName options.eventName event name, required
     * @property {Object} properties  options.properties event properties, optional
     * @property {String} eventId  options.eventId event ID, to mark the event, optional
     * @property {long} time  options.time event timeStamp, optional
     * @property {String} timeZone  options.timeZone event time zone, optional
     * @property {String} appId app id,optional
     */
    static trackOverwrite(options = {}){
        if(options['appId']){
            this.instances[options['appId']].trackOverwrite(options['eventName'],options['properties'],options['eventId'],options['time'],options['timeZone']);
        }else{
            thinkingdata.trackOverwrite(options['eventName'],options['properties'],options['eventId'],options['time'],options['timeZone']);
        }
    }

    /**
     * Record the event duration, call this method to start the timing, stop the timing when the target event is uploaded, and add the attribute #duration to the event properties, in seconds.
     * @param {String} eventName event name,required
     * @param {String} appId app id,optional
     */
    static timeEvent(eventName,appId){
        if(appId){
            this.instances[appId].timeEvent(eventName);
        }else{
            thinkingdata.timeEvent(eventName);
        }
    }

    /**
     * Enable the auto tracking function.
     * @param {TDAutoTrackEventType} autoTrackEventType Indicates the type of the automatic collection event to be enabled,required
     * @param {String} appId app id,optional
     */
    static enableAutoTrack(autoTrackEventType,appId){
        var autoTracks = [];
        if((autoTrackEventType &amp; TDAutoTrackEventType.APP_START) > 0){
            autoTracks.push(AutoTrackEventType.APP_START);
        }
        if((autoTrackEventType &amp; TDAutoTrackEventType.APP_END) > 0){
            autoTracks.push(AutoTrackEventType.APP_END);
        }
        if((autoTrackEventType &amp; TDAutoTrackEventType.APP_CRASH) > 0){
            autoTracks.push(AutoTrackEventType.APP_CRASH);
        }
        if((autoTrackEventType &amp; TDAutoTrackEventType.APP_INSTALL) > 0){
            autoTracks.push(AutoTrackEventType.APP_INSTALL);
        }
        if(appId){
            this.instances[appId].enableAutoTrack(autoTracks);
        }else{
            thinkingdata.enableAutoTrack(autoTracks);
        }
    }

    /**
     * Enable the auto tracking function with properties
     * @param {Object} options  autoTrack infomations
     * 
     * @property {TDAutoTrackEventType}autoTrackTypes options.autoTrackEventType Indicates the type of the automatic collection event to be enabled,required
     * @property {Object} properties options.properties track event  properties,required
     * @property {String} appId options.appId app id,optional
     */
    static enableAutoTrack(options = {}){
        var appId = options['appId'];
        var autoTrackEventType = options['autoTrackTypes'];
        var properties = options['properties'];
        var autoTracks = [];
        if((autoTrackEventType &amp; TDAutoTrackEventType.APP_START) > 0){
            autoTracks.push(AutoTrackEventType.APP_START);
        }
        if((autoTrackEventType &amp; TDAutoTrackEventType.APP_END) > 0){
            autoTracks.push(AutoTrackEventType.APP_END);
        }
        if((autoTrackEventType &amp; TDAutoTrackEventType.APP_CRASH) > 0){
            autoTracks.push(AutoTrackEventType.APP_CRASH);
        }
        if((autoTrackEventType &amp; TDAutoTrackEventType.APP_INSTALL) > 0){
            autoTracks.push(AutoTrackEventType.APP_INSTALL);
        }
        if(appId){
            this.instances[appId].setAutoTrackProperties(autoTracks,properties);
            this.instances[appId].enableAutoTrack(autoTracks);
        }else{
            thinkingdata.setAutoTrackProperties(autoTracks,properties);
            thinkingdata.enableAutoTrack(autoTracks);
        }
    }

    /**
     * Sets the user property, replacing the original value with the new value if the property already exists.
     * @param {Object} properties user properties,required
     * @param {String} appId app id,optional
     */
    static userSet(properties,appId){
        if(appId){
            this.instances[appId].userSet(properties);
        }else{
            thinkingdata.userSet(properties);
        }
    }
   
    /**
     * Sets a single user attribute, ignoring the new attribute value if the attribute already exists.
     * @param {Object} properties user properties,required
     * @param {String} appId app id,optional
     */
    static userSetOnce(properties,appId){
        if(appId){
            this.instances[appId].userSetOnce(properties);
        }else{
            thinkingdata.userSetOnce(properties);
        }
    }

    /**
     * Reset user properties.
     * @param {String} property user property,required
     * @param {String} appId app id,optional
     */
    static userUnset(property,appId){
        if(appId){
            this.instances[appId].userUnset(property);
        }else{
            thinkingdata.userUnset(property);
        }
    }

    /**
     * Only one attribute is set when the user attributes of a numeric type are added.
     * @param {object} properties user properties,required
     * @param {String} appId app id,optional
     */
    static userAdd(properties,appId){
        if(appId){
            this.instances[appId].userAdd(properties);
        }else{
            thinkingdata.userAdd(properties);
        }
    }

    /**
     * Append a user attribute of the List type.
     * @param {Object} properties user properties,required
     * @param {String} appId app id,optional
     */
    static userAppend(properties,appId){
        if(appId){
            this.instances[appId].userAppend(properties);
        }else{
            thinkingdata.userAppend(properties);
        }
    }

    /**
     * The element appended to the library needs to be done to remove the processing, remove the support, and then import.
     * @param {Object} properties user properties,required
     * @param {String} appId app id,optional
     */
    static userUniqAppend(properties,appId){
        if(appId){
            this.instances[appId].userUniqAppend(properties);
        }else{
            thinkingdata.userUniqAppend(properties);
        }
    }
    
    /**
     * Delete the user attributes, but retain the uploaded event data. This operation is not reversible and should be performed with caution.
     * @param {String} appId app id,optional
     */
    static userDelete(appId){
        if(appId){
            this.instances[appId].userDel();
        }else{
            thinkingdata.userDel();
        }
    }

    /**
     * Set the public event attribute, which will be included in every event uploaded after that. The public event properties are saved without setting them each time.
     * @param {Object} properties super properties,required
     * @param {String} appId app id,optional
     */
    static setSuperProperties(properties,appId){
        if(appId){
            this.instances[appId].setSuperProperties(properties);
        }else{
            thinkingdata.setSuperProperties(properties);
        }
    }

    /**
     * Clears a public event attribute.
     * @param {String} property public event attribute key to clear,required
     * @param {String} appId app id,optional
     */
    static unsetSuperProperty(property,appId){
        if(appId){
            this.instances[appId].unsetSuperProperty(property);
        }else{
            thinkingdata.unsetSuperProperty(property);
        }
    }

    /**
     * Clear all public event attributes.
     * @param {String} appId app id,optional
     */
    static clearSuperProperties(appId){
        if(appId){
            this.instances[appId].clearSuperProperties();
        }else{
            thinkingdata.clearSuperProperties();
        }
    }

    /**
     * Gets the public event properties that have been set.
     * @param {String} appId app id,optional
     * @returns Public event properties that have been set
     */
    static async getSuperProperties(appId){
        if(appId){
            return await this.instances[appId].getSuperProperties();
        }else{
            return await thinkingdata.getSuperProperties();
        }
    }

    /**
     * Set dynamic public properties. Each event uploaded after that will contain a public event attribute.
     * @param {Object} dynamicProperties dynamic public properties,required
     * @param {String} appId app id,optional
     */
    static setDynamicSuperProperties(dynamicProperties,appId){
        if(appId){
            this.instances[appId].setDynamicSuperProperties(dynamicProperties);
        }else{
            thinkingdata.setDynamicSuperProperties(dynamicProperties)
        }
    }

    /**
     * Gets prefabricated properties for all events.
     * @param {String} appId app id,optional
     * @returns preset properties
     */
    static async getPresetProperties(appId){
        if(appId){
            return await this.instances[appId].getPresetProperties();
        }else{
            return await thinkingdata.getPresetProperties();
        }
    }

    /**
     *  Set the account ID. Each setting overrides the previous value. Login events will not be uploaded.
     * @param {String} loginId account id,required
     * @param {String} appId app id,optional
     */
    static login(loginId,appId){
        if(appId){
            this.instances[appId].login(loginId);
        }else{
            thinkingdata.login(loginId);
        }
    }

    /**
     * Clearing the account ID will not upload user logout events.
     * @param {String} appId app id,optional
     */
    static logout(appId){
        if(appId){
            this.instances[appId].logout();
        }else{
            thinkingdata.logout();
        }
    }

    /**
     * Set the distinct ID to replace the default UUID distinct ID.
     * @param {String} distinctId distinct id,required
     * @param {String} appId app id,optional
     */
    static setDistinctId(distinctId,appId){
        if(appId){
            this.instances[appId].identify(distinctId);
        }else{
            thinkingdata.identify(distinctId);
        }
    }

    /**
     * Get a visitor ID: The #distinct_id value in the reported data.
     * @param {String} appId app id,optional
     * @returns distinct id
     */
    static async getDistinctId(appId){
        if(appId){
            return await this.instances[appId].getDistinctId();
        }else{
            return await thinkingdata.getDistinctId();
        }
    }

    /**
     * Obtain the device ID.
     * @param {String} appId app id,optional
     * @returns device id,optional
     */
    static async getDeviceId(appId){
        if(appId){
            return await this.instances[appId].getDeviceId();
        }else{
            return await thinkingdata.getDeviceId();
        }
    }

    /**
     * Empty the cache queue. When this function is called, the data in the current cache queue will attempt to be reported.
     * If the report succeeds, local cache data will be deleted.
     * @param {String} appId app id,optional
     */
    static flush(appId){
        if(appId){
            this.instances[appId].flush();
        }else{
            thinkingdata.flush();
        }
    }

    /**
     * The switch reporting status is suspended and restored.
     * @param {TDTrackStatus} status TDTrackStatus,required
     * @param {String} appId app id,optional
     */
    static setTrackStatus(status,appId){
        var s = TATrackStatus.NORMAL;
        if(status == TDTrackStatus.PAUSE){
            s = TATrackStatus.PAUSE;
        }else if(status == TDTrackStatus.STOP){
            s = TATrackStatus.STOP;
        }else if(status == TDTrackStatus.SAVE_ONLY){
            s = TATrackStatus.SAVE_ONLY;
        }
        if(appId){
            this.instances[appId].setTrackStatus(s);
        }else{
            thinkingdata.setTrackStatus(s);
        }
    }

    /**
     *  Enable three-party data synchronization.
     * @param {Object} options third infomations
     * 
     * @property {TDThirdPartyType} types third types,required
     * @property {Object} params extras,optional
     * @property {String} appId app id,optional
     */
    static enableThirdPartySharing(options = {}){
        var appId = options['appId'];
        var types = options['types'];
        var params = options['params'];
        var thirdTypes = [];
        if((types &amp; TDThirdPartyType.APPS_FLYER) > 0){
            thirdTypes.push(TAThirdPartyShareType.TA_APPS_FLYER);
        }
        if((types &amp; TDThirdPartyType.IRON_SOURCE) > 0){
            thirdTypes.push(TAThirdPartyShareType.TA_IRON_SOURCE);
        }
        if((types &amp; TDThirdPartyType.ADJUST) > 0){
            thirdTypes.push(TAThirdPartyShareType.TA_ADJUST);
        }
        if((types &amp; TDThirdPartyType.BRANCH) > 0){
            thirdTypes.push(TAThirdPartyShareType.TA_BRANCH);
        }
        if((types &amp; TDThirdPartyType.TOP_ON) > 0){
            thirdTypes.push(TAThirdPartyShareType.TA_TOP_ON);
        }
        if((types &amp; TDThirdPartyType.TRACKING) > 0){
            thirdTypes.push(TAThirdPartyShareType.TA_TRACKING);
        }
        if((types &amp; TDThirdPartyType.TRAD_PLUS) > 0){
            thirdTypes.push(TAThirdPartyShareType.TA_TRAD_PLUS);
        }
        console.log(thirdTypes);
        if(appId){
            this.instances[appId].enableThirdPartySharing(thirdTypes,params);
        }else{
            thinkingdata.enableThirdPartySharing(thirdTypes,params);
        }
    }

}

export { TDAutoTrackEventType,TDTrackStatus,TDThirdPartyType};
export default TDAnalytics</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.2</a> on Tue Aug 22 2023 13:53:54 GMT+0800 (China Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
